-- <실습하기> 입고 트리거 작성하기

CREATE TABLE PRODUCT(
    PCODE CHAR(6),
    PNAME VARCHAR2(12) NOT NULL,
    PCOMPANY VARCHAR(12),
    PPRICE NUMBER(8),
    STOCK NUMBER
);
ALTER TABLE PRODUCT ADD CONSTRAINT PRODUCT_PCODE_PK PRIMARY KEY(PCODE);
ALTER TABLE PRODUCT MODIFY STOCK DEFAULT 0;

CREATE TABLE RECEIVING (
    RNO NUMBER(6),
    PCODE CHAR(6),
    RDATE DATE,
    RQTY NUMBER(6),
    RPRICE NUMBER(8),
    RAMOUNT NUMBER(8)
);
ALTER TABLE RECEIVING ADD CONSTRAINT RECEIVING_RNO_PK PRIMARY KEY(RNO);
ALTER TABLE RECEIVING ADD CONSTRAINT RECEIVING_PCODE_FK FOREIGN KEY(PCODE) REFERENCES PRODUCT(PCODE);
ALTER TABLE RECEIVING MODIFY RDATE DEFAULT SYSDATE;

INSERT INTO PRODUCT(PCODE, PNAME, PCOMPANY, PPRICE)
    VALUES('A00001','세탁기', 'LG', 1500000);
INSERT INTO PRODUCT(PCODE, PNAME, PCOMPANY,PPRICE)
    VALUES('A00002','컴퓨터', 'LG', 1000000);
INSERT INTO PRODUCT(PCODE, PNAME, PCOMPANY,PPRICE)
    VALUES('A00003','냉장고', '삼성', 4500000);
    

DESC PRODUCT;    
DESC RECEIVING;

-- 트리거 생성 입고(RECEIVING) 입력이 되면 재고(PRODUCT) 수량의 입고 수량이 저장되는 트리거를 생성할 것

CREATE OR REPLACE TRIGGER RECEIVING_TRIGGER01
    AFTER INSERT ON RECEIVING
    FOR EACH ROW
BEGIN
    UPDATE PRODUCT SET STOCK = STOCK + :NEW.RQTY
    WHERE PCODE = :NEW.PCODE;
END;
/

INSERT INTO RECEIVING(RNO,PCODE, RQTY, RPRICE, RAMOUNT)
VALUES((SELECT NVL(MAX(RNO),0)+1 FROM RECEIVING), 'A00002', 10, 680000, 780000);
INSERT INTO RECEIVING(RNO,PCODE, RQTY, RPRICE, RAMOUNT)
VALUES((SELECT NVL(MAX(RNO),0)+1 FROM RECEIVING), 'A00003', 20, 3000000, 3000000);
INSERT INTO RECEIVING(RNO,PCODE, RQTY, RPRICE, RAMOUNT)
VALUES((SELECT NVL(MAX(RNO),0)+1 FROM RECEIVING), 'A00001', 30, 1000000, 1000000);
INSERT INTO RECEIVING(RNO,PCODE, RQTY, RPRICE, RAMOUNT)
VALUES((SELECT NVL(MAX(RNO),0)+1 FROM RECEIVING), 'A00001', 10, 1000000, 1000000);
SELECT * FROM PRODUCT;
SELECT * FROM RECEIVING;

-- 갱신트리거 만들기 입고수량을 30=>10 진행을 했는데 마지막 10개를 5개로 수정하면 PRODUCT 재고수량을 수정하는 트리거를 만들 것
CREATE OR REPLACE TRIGGER RECEIVING_TRIGGER
    AFTER UPDATE ON RECEIVING
    FOR EACH ROW
BEGIN
    UPDATE PRODUCT SET STOCK = STOCK + (-:OLD.RQTY + :NEW.RQTY) WHERE PCODE = :NEW.PCODE;
END;
/

UPDATE RECEIVING SET RQTY = 8, RPRICE = 1000000, RAMOUNT = 1000000 WHERE RNO = 3;
ROLLBACK;
SELECT * FROM PRODUCT;
SELECT * FROM RECEIVING;
DELETE FROM RECEIVING WHERE RNO = 4;

-- 삭제트리거 (입고부분에서 삭제가 되면 재고부부에서 삭제된 수량을 빼준다)

CREATE OR REPLACE TRIGGER RECEIVING_DEL_TRIGGER
    AFTER DELETE ON RECEIVING
    FOR EACH ROW
BEGIN
    UPDATE PRODUCT SET STOCK = STOCK - (:OLD.RQTY) WHERE PCODE = :OLD.PCODE;
END;
/

SELECT * FROM RECEIVING;
SELECT * FROM PRODUCT;

DELETE FROM RECEIVING WHERE RNO = 3;

-- FUNCTION 부서번호를 입력하면 부서명을 리턴해주는 함수를 만드시오.
-- 부서번호가 없는 번호라면 '해당부서없음' 값으로 리턴하시오.
CREATE OR REPLACE FUNCTION GET_DEPARTMENT_NAME_FUNC(VDEPARTMENT_ID EMPLOYEES.DEPARTMENT_ID%TYPE)
RETURN VARCHAR2
IS
    VDEPARTMENT_NAME VARCHAR2(100);
    VCOUNT NUMBER := 0;
BEGIN
    -- 해당부서의 카운트를 체크
     SELECT COUNT(*) INTO VCOUNT FROM EMPLOYEES WHERE DEPARTMENT_ID = VDEPARTMENT_ID;

    IF(VCOUNT = 0) THEN
        VDEPARTMENT_NAME := '해당부서없음';
    ELSE
        SELECT DEPARTMENT_NAME INTO VDEPARTMENT_NAME FROM DEPARTMENTS WHERE DEPARTMENT_ID = VDEPARTMENT_ID;
    END IF;
    RETURN VDEPARTMENT_NAME;
END;
/
-- 함수를 이용해서 부서번호를 매개변수 등록하고 부서명 구하는 기능 사용
SELECT * FROM DEPARTMENTS WHERE DEPARTMENT_ID = 100;
SELECT FIRST_NAME, SALARY, DEPARTMENT_ID, GET_DEPARTMENT_NAME_FUNC(DEPARTMENT_ID) AS "DEPARTMENT_NAME"
FROM EMPLOYEES WHERE FIRST_NAME = 'Lex';

VARIABLE VNAME VARCHAR2;
EXECUTE :VNAME := GET_DEPARTMENT_NAME_FUNC(90);
PRINT VNAME;